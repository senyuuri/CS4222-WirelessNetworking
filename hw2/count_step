#!/usr/bin/python
import sys
import math

# window size for mean square calculation
W_SIZE = 15

# threshold
LIMIT_T1 = 2.0
LIMIT_T2 = 1.0

# read filename from command
if len(sys.argv) < 2:
	print('usage: ./count_step csvfile')
	sys.exit(2)

# initialisation
magnitude = []
b = []
fname = sys.argv[1]

# read csv file
# try:
with open(fname, 'r') as fin:
	lines = fin.readlines()
	for line in lines:
		r = [float(x) for x in line.split(',')]
		# compute magnitude of acceleration
		a = math.sqrt(math.pow(r[0],2) + math.pow(r[1],2) + math.pow(r[2], 2))
		magnitude.append(a)
# except:
# 	print('IO Error')
# 	sys.exit(2)

for i in range(W_SIZE, len(magnitude) - W_SIZE):
	# get the slice of current window
	w = magnitude[i - W_SIZE : i + W_SIZE + 1]
	# compute local mean in the range of [i-W_SIZE, i+W_SIZE]
	lmean = sum(w) / (2 * W_SIZE + 1)
	# compute local variance
	var = sum([math.pow((x - lmean),2) for x in w]) / (2 * W_SIZE + 1)
	# apply threshold
	b1 = 1 if math.sqrt(var) > LIMIT_T1 else 0
	b2 = 1 if math.sqrt(var) < LIMIT_T2 else 0
	b.append((b1, b2))

# count steps
steps = 0
for i in range(1, len(b) - 1):
	# condition 1: a transition from high to low acceleration
	if b[i][0] > b[i-1][0]:
		# condition 2: there must be at least one low acceration detected in
		# a window of size w ahead of the current sample
		end = (len(b) - 1) if ((i + W_SIZE) >= len(b)) else i+W_SIZE
		for j in range(i+1, end+1):
			if b[j][1] == 1:
				steps += 1
				break

print(steps)